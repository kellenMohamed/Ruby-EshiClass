Selenium é um framework
Cucumber é um ferramenta para usar Gherkin
Hooks: Controla os eventos (Before, After, etc) para os métodos. Usado no Cucumber
SitePrism faz interação com elementos e validações (vários métodos prontos como validar se tem um texto X no elemento.)
	Para isso precisa instanciar o elemento como SitePrism.
	Facilita como lidar com iFrames ao invés de usar métodos nativos do selenium ou capybara.
PageObjects: Para cada página haverá uma classe. Cada elemento terá um atributo (Ex. um botão terá um atributo para representálo).
		Cada ação terá um método.



imersaorubyguts2021@gmail.com
https://discord.gg/tXqwSZWD


-- Iniciando o Projetos --
--
PASSOS:
--
1. Primeiro instalar o ruby e chromedriver (seguir doc de instalação)
2. Crie uma pasta para o projeto.
3. Dentro da pasta crie um arquivo Gemfile
4. Coloque no arquivo as gems que precisam ser criadas:
source 'https://rubygems.org'

gem 'selenium-webdriver'
gem 'capybara'
gem 'site_prism'
gem 'rspec'
gem 'cucumber'

5. Abra um terminal no projeto e execute o comando: bundle install
	Esta execução cria o arquivo Gemfile.lock
6. Execute o comando cucumber --init
	Este comando acima cria a estrutura de pastas do cucumber.

7. Dentro da pasta features cria uma pasta chamada "pages"
8. Dentro da pasta features cria uma pasta specs
9. Configure o arquivo env.rb, colocando as biblitecas citadas no Gemfile e tbm configurando o Driver avisando que vai usar o site_prism mas será um driver do Selenium
	Além disso, precisa dizer pro Driver qual o parâmetro de entrada: app e browser.
	E para não configurar ou baixar o chromeDriver deve-se usar o WebDriverManager que usa o node js.
	Assim, no browser deve-se colocar o endereço da porta onde o webDriver (URL) está rodando o serviço de driver.
	Para o webDriver manager deve-se passar a desired capability, que são opções de configuração para o Chrome.
	Por último deve-se configurar o capybara.
	Abrir o browser maximizado e configurar o tempo máximo de resposta.

	require 'rspec'
	require 'selenium-webdriver'
	require 'capybara/cucumber'
	require 'site_prism'
	require 'rspec'
	require 'cucumber'

	Capybara.register_driver :site_prism do |app|
		Capybara::Selenium::Driver.new(app, browser: :remote, :url => 'http://localhost:4444/wd/hub', :desired_capabilities => :chrome)
	end

	Capybara.configure do |config|
		config.run_server = false
		Capybara.default_driver = :site_prism
		Capybara.page.driver.browser.manage.window.maximize
		config.default_max_wait_time = 10
		config.app_host = 'http://www.automationpractice.com/index.php'
	end


	Após dentro da pasta "support" criar a classe "App" para que não precise sempre instanciar cada classe criada durante os testes.
	Assim, no início dos testes ela gera uma instância na nossa page.
		class App 
		
		end

	Após dentro da pasta "support" criar o arquivo de "hook", que é um arquivo que gerencia os momentos do ciclo de teste.
		* Chama as classes sem precisar dar new para cada uma:

		Before do
   			 @app = App.new
		end
		
		* Se o cenário falhar ele tira o print de cada falha:
		* Concatenar uma String com uma variável (ingestão do valor de uma variável dentro de uma String), para isso precisa:
			usar aspas duplas por fora e o #

		After do |scenario|
       			 if scenario.failed?
            			page.save_screenshot("screenshots/#{scenario.name}#{Time.now}_screenshot.png")
        		 end
		end  

	Após dentro do pojeto criar o arquivo cucumber.yml que gerará o report (DA FORMA ABAIXO GERA DIRETO NA RAIZ DO PROJETO - isso pode ser configurado passando o caminho antes:)
		default: --no-source --color --format pretty --format html --out report.html

	
	Também precisa executar no cmd:
		webdriver-manager start
* Depois a feature.

*** Para executar o feature o comando é:
	cucumber -t @cadastro_dados_fixos

Ao executar será informado os steps sugeridos da execução.
	Deve-se criar dentro da pasta "step_definitions" o arquivo cadastro_steps.rb
	E colar os steps citados na execução.
		Dado('que acesso a p├ígina de login\/cadastro') do
    			pending # Write code here that turns the phrase above into concrete actions
  		end
		*** Tem a barra de escape acima (contrabarra) porque no cenário tinha a barra que é considerada caracter special, por isso ele cria \/

* Após, como já temos a URL criada dentro do arquivo "env.rb" vamos criar a page dentro de "pages".
	Esta page tem que ter uma classe que herda do Site prism (ser do tipo site prism para ter interação com os elementos como se fosse o Selenium)
		class CadastroPage < SitePrism::Page

	Para acessar a page tem que colocar o endereço extra da página que está no final da url e usar o método set_url:
		class CadastroPage < SitePrism::Page
    			set_url '?controller=authentication&back=my-account'
		end

******** Voltando aos Steps: ********
1. Como a classe App vai instanciar as classes temos que incluir na classe App.rb qual classe quer instanciar:
	class App
    		def cadastropage
        		cadastroPage.new
    		end
	end

E ai dentro dos steps é só chamar a classe App para carregar a página.
	Dado('que acesso a p├ígina de login\/cadastro') do
    		@App.cadastropage.load
	end
  

Após chama-se o método para cadastrar o email, esse método chamado na cadastro_steps.rb deve ser definido na "cadastro_page.rb" dentro da classe que está sendo criada:
	  Dado('solicito um novo cadastro para o email {string}') do |email|
    		@App.cadastropage.iniciar_criacao_conta email
  	  end
	OBS: Dentro de || está o parãmetro que será recebido, no caso é o |email|

Após deve-se implementar o método no arquivo "cadastro_page.rb" dentro da classe e agora informando que receberemos elemento:
	Os elementos do site prism por padrão receberem um css selectors.
	Se quiser pode passar um :xpath, 'seletor' (não é o nosso caso, passaremos apenas o 'seletor')


*** Como achar um elemento dentro de uma lista para seleção. Ex para o estado:
	Na classe foi definido os campos inspecionados:
	    	element :state_select,'#uniform-id_state'
    		# Criando uma lista (para buscar os estados do selector acima):
    		elements :state_option, '#uniform-id_state option'
	No método foi tratado o valor a ser buscado:
        	state_select.click
        	option = state_options.find {option| option.text.include?("Alabama")} 
        	option.click


*** Após definir os Passos 2,3 e 4 do arquivo cadastro_steps.rb dentro de cadastro_page.rb (com classe e método).
	Devemos criar a segunda página dentro da pasta "pages" chamada "minha_conta_page.rb"
	Esta page tem que ter uma classe que herda do Site prism (ser do tipo site prism para ter interação com os elementos como se fosse o Selenium)
		class MinhaContaPage < SitePrism::Page
    			set_url '?controller=my-account'
		end

*** No step "então" precisa fazer as assertions usando o expect:
	Então('devo ser direcionado à página de minha conta') do
  		#As assertions devem ser feitas dentro do Step:  
  		#expect(@app.minhacontapage.acessou_minha_conta).to be_trutly
  		expect(@app.minhacontapage.page_title.text).to eq('MY ACCOUNT')
  		expect(@app.minhacontapage.account_name.text).to eq('Kellen Fernandez')
	end

* Não devemos fazer as assertions dentro da page, pois:
	a page deve mapear o elemento e definir o elemento.
		Ex page:
			class MinhaContaPage < SitePrism::Page
    				# A page deve mapear o elemento e definir o elemento não as assertions:
    				set_url '?controller=my-account'
    				element :page_title,'page-heading'
   				element :account_name,'[title="View my customer account"]'

			end


---------------****---------------------
*** Para setar um email aleatório usando o Faker dentro do método:
        email.eql?('aleatório') ? Faker::Internet.email(domain: 'guts') : email

# Variáveis:
@ = é uma variável de instância (ao terminar a execução do seu escopo ela deixa de existir.
@@ = é uma variável de classe (fica disponível no ciclo de vida da classe)
$ = é uma variável de escopo global (pode ser acessada de qualquer lugar do código).

*** O Kafer gera nome e outros campos aleatórios como password (para colocar dentro dos campos do método):
	first_name_field.set Faker::Name.first_name
        last_name_field.set Faker::Name.last_name
        password_field.setFaker::Internet.passwd(min_lenght: 5, max_lenght: 10, mix_case: true, special_character: true)
	mobile_phone.set Faker::PhoneNumber.cell_phone_in_e164 (o comando e164 do fake é para considerar no padrão brasileiro).

unless: é o oposto do if: se não acontecer isso faz isso (usado no método). No exemplo abaixo se não for Não ele executa o click:
	unless newsletter.eql?('no') 
            newsletter_checkbox.click
        end


************ --- ************

Para ter um feature que lê um arquivo, precisa:

1. Deve-se criar dentro da pasta "data" um arquivo user_info.yml que vai conter os dados do teste:
email: "new_user_yml@guts.com"
gender: "fem"
first_name: "Ralni"
last_name: "Fernandez"
password: "12345"
day: "20"
month: "January"
year: "1986"
newsletter_: "yes"
address: "Street A"
city: "São Carlos"
state: "Alabama"
zipcode: "99345"
phone: "16991565654"
address_name: "Predio"


2. Após deve-se criar um arquivo data.rb dentro da pasta "data" para ter as bibliotecas necessária e o parse do json que será utilizado na cadastro_page.rb:
require 'json'
require 'yaml'
require 'ostruct'

class UserData
    @data = JSON.parse(YAML.load(File.read('features/supoport/data/user_info.yml')).to_json, object_class: OpenStruct)

    #Método para expor o @data e pegar os dados:
    #O método já passa a chave que quer e ele devolve o valor da chave, sem precisar de um array para varrer a classe:
    def self.get(info)
        @data.send(info)
    end        
end     

3. Depois é só ir na cadastro_page.rb (dentro da classe: class CadastroPage < SitePrism::Page) e colocar no método para pegar os dados do arquivo user_info.yml:

    # Implementar o método que foi chamado no step da cadastro_steps.rb
    # Inspecione a página do teste para saber o nome dos elementos.
    # Método para o step 2:
    def iniciar_criacao_conta(email)
        # Criar a ação para os elementos:
        case email
        when 'aleatorio'
            @email = Faker::Internet.email(domain:'guts')
        when 'padrao'
            @email = Data.get(email)
        else
            @email = email
        end
        # No comando abaixo com o set ele sabe que precisa pegar o valor do email aleatório:
        #puts @email = email.eql?('aleatorio') ? Faker::Internet.email(domain:'guts') : email
        email_create_account_field.set email
        create_account_btn.click
    end

def preencher_form_com_dados_datafile
        #Em Data.get após passa a chave (nome do campo) dentro do arquivo user_info.yml:
        Data.get(gender).qdl?('fem') ? title_fem_rd.set(true) : title_mas_rd.set(true)
        @@first_name = Data.get(first_name)
        first_name_field.set  @@first_name
        @@last_name = Data.get(last_name)
        last_name_field.set @@last_name
        password_field.set Data.get(password)
        days_select.select Data.get(day)
        month_select.select Data.get(month)
        year_select.select Data.get(year)
        #unless é o oposto do if: se não acontecer isso faz isso
        unless Data.get(newsletter).eql?('no') 
            newsletter_checkbox.click
        end
        address_field.set Data.get(address)
        city_field.set Data.get(city)
        state_select.click
        option = state_options.find {option| option.text.include?(Data.get(state))} 
        option.click
        zip_code_field.set Data.get(zipcode)
        mobile_phone.set Data.get(phone)
        address_alias_field.set Data.get(address_name)  
    end


**** Toda classe começa com class e termina com end
**** Todo método começa com def e termina com end
**** Blocos e funções também terminam com end


